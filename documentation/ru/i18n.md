**Оглавление**

- [Файлы перевода](#langfiles)
- [Определение и хранение языка](#detect)
- [Класс I18n, доступ из кода](#source)
- [Формат сообщений](#format)
- [Локализация в шаблонах](#template)

---

### Локализация

Локализация (I18n) является средством для перевода приложения на различные языки. Следуйте
инструкциям этой статьи чтобы осуществить локализацию вашего проекта на Regenix.


#### Только UTF-8

Regenix всегда использует только одну кодировку UTF-8, поэтому необходимо использовать только эту кодировку
и в локализации. Кодировка UTF-8 позволяет без проблем отображать контент на всех мировых языках,
JSON работает только с кодировкой UTF-8 и это лишь несколько причин использовать только данную
кодировку в своих проектах.


#### Файлы перевода <a name="langfiles"></a>

Regenix использует отдельный файл перевода для каждого языка. Эти файлы хранятся в папке проекта
`/conf/i18n/`, название файла соотвествует его языку, например `ru.lang`, является файлом для
локализации на русский язык. Также там имеется файл `default.lang`, этот файл используется
в случае неопределенности языка, его можно также использовать для какого-то одного главного
языка, например для английского.

Файлы перевода имеют следующий формат, пример:

    hello = Привет!
    back = назад
    Admin Panel = Административная Панель
    Hello, {0} user = Приветствуем тебя, {0}

Т.е. на каждой строчке распологается фраза-оригинал и ее перевод. Вместо фразы вы можете использовать
просто символьный код. Формат сообщений поддерживает параметры, `{0}` означает нулевой параметр, первый
по счету, который передан в функцию перевода. Об этом далее.


#### Определение и хранение языка <a name="detect"></a>

Regenix поддерживает из коробки несколько способов распознания и хранения языка пользователя:

- *route*: по аргументу в правиле роутинга
- *get*: по значению из get параметра
- *headers*: по заголовку accept-language, определяет язык браузера пользователя
- *session*: берет значение языка из сессии
- *none*: берет значение языка из настроек в конфигурации

Способ работы определения и хранения языка задается в файле конфигурации под опцией
`i18n.detect.type`.

    # route, get, headers, session or none
    i18n.detect.type = route

По-умолчанию названием аргумента языка является `_lang`, но его можно поменять в настройках
`application.conf`, опция `i18n.detect.arg` задает имя этого аргумента.

Для построения мультиязычности сайта на основе url (*route*), необходимо прописывать язык в
правилах роутинга:

    GET   /{_lang}/       Application.index

Если вы решили использовать способ *get*, то должны сами формировать ссылки с GET параметром `_lang`.
Например `/page/?_lang=ru`.

Вы также можете определить язык по-умолчанию, если тот не определен, обычно это язык под кодом `default`.

    # in application.conf
    i18n.lang = ru


#### Класс I18n, доступ из кода <a name="source"></a>

Класс `I18n` является основным для локализации приложений. Он содержит несколько полезных
методов. Первое, позволяет из кода достать текущее переведенное сообщение, учитывая
текущий язык.

    $message = I18n::get('hello');
    $message = I18n::get('Hello, {0} user', $userName);

Он также позволяет сменить язык програмно (т.е. вручную), делается это с помощью метода `setLang`.

    I18n::setLang('ru');

Для того чтобы определить, доступен ли перевод для какого-либо языка используйте метод `availLang`.

    $langAvail = I18n::availLang('ru');

Если не передавать в `availLang` язык, то будет осуществлена попытка определить язык исходя из
настроек конфигурации и проверка его на доступность. Это может пригодится для ограничения в динамических
url адресах для несуществующих еще языковых переводов.

В контроллере:

    if (!I18n::availLang()){
        $this->notFound();
    }



#### Формат сообщений <a name="format"></a>

В сообщения для локализации можно передавать аргументы. Для обозначения этих аргументов
в сообщении используются фигурные скобки `{0}`. 0 - в данном случае означает первый по счету
переданный аргумент. Вы также можете передавать именнованные аргументы в сообщение `{name}`.

    I18n::get('User count = {0}.', $count);
    I18n::get('User count = {count}.', array('count' => $count));

У вас могут быть проблемы если вы будете использовать `=` символ как часть сообщения, поэтому
этот символ нужно экранировать в (!) файлах перевода, в `.lang` файлах:

    User count \= {0} = Кол-во пользователей \= {0}
    User count \= {count} = Кол-во пользователей \= {count}


#### Локализация в шаблонах <a name="template"></a>

В шаблонизатор встроена специальная конструкция для вставки локализированных сообщений.
Делается это очень просто:

    &{'User count = {0}', $count}

С помощью '&{...}' конструкции можно вставлять локализированные сообщения. По-умолчанию
она экранирует html-символы сообщения. Вы также можете использовать функцию `__()`, чтобы
осуществить локализацию в шаблоне, там где необходим вызов как функции.

    ${ __('User count = {0}', $count) }

Но рекомендуется использовать первый вариант, там где это только возможно.