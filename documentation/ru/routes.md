**Оглавление**

- [О Rest архитектуре](#rest)
- [Конфигурация роутинга (ЧПУ)](#syntax)
    - [URI Шаблоны](#pattern)
    - [Вызов PHP методов](#actions)
- [Доступ к именнованным аргументам роутинга](#routeargs)
- [Приоритет правил роутинга](#priority)
- [Статичные файлы](#static)
- [Аргументы помошники](#helpers)
- [Динамическое добавление](#dynamic)

*[к оглавлению](main.md)*

---

### HTTP Роутинг (ЧПУ)

Роутинг отвечает связывание HTTP-запросов с вызывом действий - методы контроллеров (Controller).

Запрос HTTP является событием, в рамках MVC. Событие хранит в себе следующую информацию:

- Запрос url адреса (например, `/clients/1542`, `/photos/list`), в том числе и строку запроса
- Метод HTTP (GET, POST, PUT, DELETE)


#### О REST архитектуре <a name="rest"></a>

Representational State Transfer (REST) является одной из архитектурой для web-приложений.

REST строится на нескольких принципах:

- Функциональные возможности приложения делятся на ресурсы
- Доступ к каждому ресурсу осуществляется через URI
- Все ресурсы используют единый интерфейс для передачи состояния между клиентом и ресурсами.

Если вы используете HTTP, эти интерфейсы определяются набором доступных методов HTTP.

Если приложение следует основным принципам REST, приложение называют RESTful.
Regenix позволяет легко создавать RESTful приложения.

- Regenix роутинг обеспечивает связь между URL и вызовом методов контроллера. Поддерживаются регулярные выражения, с помощью которых можно задавать более гибкие правила.
- Протокол не хранит состояния. Это означает, что вы не можете сохранить состояние на сервере между двумя последовательными запросами.
- Regenix обеспечивает полный доступ ко всей информации HTTP запросов.


#### Конфигурация роутинга (ЧПУ) <a name="syntax"></a>

Конфигурирование роутинга происходит через специальный файл, находищийся в папке проекта `conf/route`.
В этом файле перечисляются все правила обращения по url, каждое такое правило содержит в себе
тип HTTP запроса (GET, POST и т.п.), шаблон URI и название метода контроллера, который будет
вызван по этой схеме.

Давайте посмотрим на пример:

    GET      /clients/{id}/      Clients.show

Каждое правило начинается с метода HTTP, затем URI и вконце название метода контроллера. Разделение происходит
с помощью пробела или таба.

Вы также можете добавить строки комментирования в файл роутинга, для этого используйте символ `#`.

    # Display a client
    GET    /clients/{id}/        Clients.show


**HTTP Методы**

HTTP Методом может быть любой поддерживаемый метод протоколом HTTP:

- POST
- GET
- PUT
- DELETE
- HEAD

Если необходимо убрать зависимость от метода, воспользуйтесь символом `*`, который означает - любой из
возможных методов HTTP.

    *   /cliens/{id}/       Clients.show

Данное правило будет обрабатывать любые (POST, GET и т.д.) запросы, например, по адресу `/clients/345/`.


#### URI Шаблоны <a name="pattern"></a>

URI шаблон определяет путь запроса роутинга. Некоторые части пути могут быть динамическими.
Любая динамическая часть в правиле заключается в фигурные скобки `{...}`.

Правило `/clients/all` всегда будет соответствовать одному url адресу `/clients/all`.
Но, например, правило `/clients/{id}/` уже является динамическим и может соответствовать разным url
адресам, например: `/clients/3908/`, `/clients/todo/` и др.

Правило URI может содержать более одной динамической части, например:

    /clients/{id}/accounts/{accountId}/

По-умолчанию динамическая часть в урл соответствует `/[^/]+/` регулярному правилу, но вы
можете всегда его переопределить следующим образом:

    /clients/{<[0-9]+>id}/

Данный пример будет открывать url, только с числами в качестве `id`. Давайте попробуем усложнить:

    /clients/{<[a-z]{4,10}>id}

Здесь `id` уже будет соотвествовать только слову из букв, длина которого от 4 до 10 символов.

В итоге вы можете использовать любые регулярные выражения без ограничений.
> Динамические части правила всегда имеют **имя**. По этому имени вы сможете получить значение
> динамической части url из своего кода, например в контроллере.

По-умолчанию Regenix не игнорирует слэш вконце правила, поэтому если вконце указан слэш,
то адрес без слеша будет выдавать 404 ошибку.

    GET     /clients/        Clients.index

Cтраница `/clients/` не будет открываться и по адресу `/clients`. Для того чтобы она открывалась
по обоим адресам, необходимо использовать `?` символ из регулярных выражений, делается это
очень просто:

    GET     /clients/?       Clients.index

В итоге страница сможет открываться и без слэша на конце.


#### Вызов PHP методов <a name="actions"></a>

Последняя часть в описаниии правила является названием класса+метода контроллера. Метод
контроллера должен быть объявлен как `public function`, он не должен быть статичным. Сам
класс контроллера не должен быть абстрактным. Все классы контроллеров должны находиться
в namespace `controllers`, в папке проекта `/app/controllers/`. Название файла контроллера
должно быть таким же как название его класса (по стандарту PSR-0).

Вы можете создавать контроллеры в под-пакетах (под-папках), например `controllers\sub`.
В роутинге можно указать название под-namespace, через `.`. Пример:

    GET    /admin             admin.Dashboard.index

В данном случае по адресу `/admin` Regenix попытается вызвать метод `index` от экземпляра
класса `controllers\admin\Dashboard`.


#### Доступ к именнованным аргументам роутинга <a name="routeargs"></a>

Чтобы получить значение аргумента из правила роутинга, можно использовать аргументы метода
контроллера, называя их также как в правилах из файла `/conf/route`. Рассмотрим пример:

    public function page($id){
        $page = Page::getService()->findById($id);
        $this->put('page', $page);
        $this->render();
    }

Даллее описываем правило в файле роутинга таким образом:

    GET    /pages/{id}        Application.page

Вы также можете указать значения по умолчанию, используя стандартные возможности PHP:

    public function page($id = 'home'){
    ...

Если вы хотите, чтобы значения аргументов приходили уже в нужном типе, укажите это
в правиле следующим образом:

    GET   /pages/{id:int}   Application.page

В результате `id` всегда будет конвертироваться в `integer` значение (число). Доступны
и другие типы: *string*, *boolean*, *double*. Вы также можете указать и название класса, но об
этом в другом разделе.

Кроме того, указав `$id` в аргументах метода контроллера, он будет автоматически ассоциирован
и с `$_GET` параметрами, но приоритет связывания у аргументов роутинга больше. Такая возможность
позволяет также автоматически ассоциировать и get параметры из url адреса.

Вы также можете воспользоваться полем контролера `routeArgs`, чтобы получить значения этих аргументов.

    public function page(){
        $id = $this->routeArgs['id'];
        ...
    }


#### Приоритет правил роутинга <a name="priority"></a>

Один запрос может совпадать с несколькими правилами роутинга, таким образом появляются конфликты.
Но в случае конфликта, будет использовано самое верхнее-первое правило из конфигурации роутинга.

Для примера:

    GET    /clients/all       Clients.listAll
    GET    /clients/{id}      Clients.show

Если мы запросим адрес `/clients/all`, то будет вызван метод `Clients.listAll`, т.к. он находится
выше в правилах. Если запросим `/clients/other` - будет вызван метод `Clients.show`.


#### Статичные файлы <a name="static"></a>

На роутинг не распрастраняется регулирование правил доступа к статичным файлам, хотя это
возможно эмулировать через контроллеры. Статичные файлы должны быстро отдаваться и поэтому
не должны обрабатываться фреймворком, т.к. это может вызвать падение производительности.
Поэтому в файле `.htaccess` заранее прописаны правила доступа к статичным файлам.

Все файлы находящиейся в следующих папках будут обрабатываться как статичные файлы:

    /apps/<name>/assets/
    /public/<name>/
    /modules/<name>/assets/

Эти папки необходимо использовать для хранения статичных файлов - js, css, картинок и т.д.
Правила доступа к этим папкам описаны в `.htaccess`.

    # MODULES
    RewriteRule ^modules/([a-z0-9-_A-Z]+)/assets/(.*)$ - [L]

    # PUBLIC
    RewriteRule ^public/([a-z0-9-_A-Z]+)/(.*)$ - [L]

    # ASSETS
    RewriteRule ^apps/([a-z0-9-_A-Z]+)/assets/(.*)$ - [L]

Вы также можете добавить похожие правила обработки статичных файлов в конфигурацию nginx или
другого веб-сервера. Фреймворк может изменять шаблон формирования url к статичному файлу, это
позволяет разработчику легко отделить файловый сервер для статики от веб сервера. Но об
этом в других разделах.


#### Аргументы помошники <a name="helpers"></a>

В правилах роутинга всегда доступен аргумент-помошник `_METHOD`, который хранит название
HTTP метода запроса. Его можно использовать как обычный аргумент роутинга,
для примера:

    *   /form/      Application.form_{_METHOD}

Таким образом при GET запросе будет попытка вызвать метод `form_GET`, при POST запросе - `form_POST`,
и так с любыми методами.

Вы также можете получить этот аргумент и в методе контроллера, например:

    public function form($_METHOD){
        ...
    }


#### Динамическое добавление <a name="dynamic"></a>

В фреймворке есть возможность добавить правило роутинга динамически - с помощью метода.
Для этого необходимо использовать класс Router и его метод addRoute. Обычно такое
добавление правил не используется в стандартном проекте Regenix, оно часто
пригождается при написании модулей, когда по-каким то условиям необходимо
добавлять разные правила для роутинга.

Пример динамического добавления:

    $project = Project::current();
    $project->router->addRoute('GET', '/clients/{id}/', 'Clients.get');

Как видно, у метода 3 параметра - HTTP метод, шаблон url и название контроллера+метод.
`Project::current()` получает объект текущего проекта, об этом вы сможете прочитать
в других разделах.